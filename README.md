# SystemDesign

Consistent Hashing & Design TinyUrl
简单的ConsistentHashing方法的回顾

当数据在一台机子无法存储的时候，有两个办法解决，竖着切和横着切，竖着：不同的表放在不同的机器上。
横着：同一张表的数据放在不同的机器上
需要平均的分布在不同的机器上（一致性hash就是为了解决横向切分的平均）

一致性hash
1.%n的方法是一种简单的hash算法（对机器的数量取摸）
2.这是一种不一致性hash算法，当n变为n+1的时候75%的数据都会发生迁移，即%n和%n+1结果基本上都不一样
3.所以这个hash算法称为不一致hash算法

需要解决：减少数据的移动
ConsistentHash出现，数据都会%360

进行区间划分，DB0：0-179，DB1：180-359，新增机器的时候，另外两台机器均分（只有1/3的数据移动）

如果有三台机器，新增第四台机器的时候，去查找连续区间最大的两个区域，然后再进行划分。

缺点：数据分布不均匀，个别机器的迁移数据压力过大

更好的一致性Hash：
将整个Hash区间看做环
这个环的大小从360变为2的64次方减一
将机器和数据看做环上的点
引入虚拟节点的概念，一台机器对应100台虚拟节点，这100个虚拟节点都会代表A机器
这样的话机器的数量在环上就会均匀分布



机器的名字hash值 对应到环上的某个点 A
数据hashFunc之后 对应到环上的某个点 D，顺时针去找离自己最近的某台机器，会把该数据放到该机器上

当新加入一台机器的时候做数据迁移的时候：
1000个虚拟节点，各自向顺时针的一个虚拟节点要数据
结论：
TreeMap可以存储这个环，红黑树，log（n）的时间


Replica 数据备份
BackUp和replica区别，一个定期做是死数据，另一个是实时的活数据
以mysql为代表的SQL型数据库，自带master slave的replica方法，
master负责写，slave负责读，slave从master中同步数据

原理是写head log
.sql数据库的任何操作，都会以log的形式做一份记录
.master每次有任何操作就会通知slave来读log
因此slave上的数据都是有延迟的
master挂了怎么办呢？将一台slave机器升级到master，接受读写

Nosql的replica的方式是consistentHash环上顺时针存三份

TinyUrl
分析流量，不要一上来就认为流量巨大无比
场景分析1、提问：分析功能、需求、QPS、存储容量
2、画图：根据分析结果设计可行解
3、进化：研究可能出现的问题，优化系统

新浪微博
QPS：2k，推算存储







